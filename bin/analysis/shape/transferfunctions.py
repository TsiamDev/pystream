from __future__ import absolute_import

from . model import expressions


def reachable(index, secondary):
	return index.currentSet or secondary.externalReferences

def gcMerge(sys, point, context, index, secondary):
	if reachable(index, secondary):
		sys.environment.merge(sys, point, context, index, secondary)

# If the configuration cannot be refered to by the expression, there's no point in recording it as a miss.
# TODO only check one configuration, all configurations generated by "map configuration" will have the same live reference set.
def filterTrivialMisses(sys, configuration, misses):
	filtered = set()
	for e in misses:
		if configuration.referedToBySlot(e.slot):
			filtered.add(e)
	return filtered

def substitute(sys, expressions, e1, e0):
	newExpressions = set()
	for e in expressions:
		#print "!!!", e
		newE = e.substitute(sys, e1, e0)

		# Local references are "trivial" as they can be easily infered from the configuration.
		if newE and not newE.isTrivial():
			newExpressions.add(newE)
	return newExpressions


def substituteUpdate(sys, expressions, e1, e0):
	subs = substitute(sys, expressions, e1, e0)

	expressions.update(subs)


def filterUnstable(sys, exprs, slot, stableValues):
	#assert isinstance(stableValues, frozenset), stableValues

	# Location stable value implies stable location.
	# As such, this is simplified from code given in the paper.

	if exprs is stableValues:
		# Optimization, all the values are known stable, so just check the locations.
		return set([e for e in exprs if e.stableLocation(sys, slot, stableValues)])
	else:	
		return set([e for e in exprs if e.stableValue(sys, slot, stableValues)])


def mapConfiguration(sys, i, slot, b0, b1):
	# e0 = e1
	# If neither points to the configuration i question, do nothing.
	# If both point to the configuration, there is no change, so do nothing.
	
	# Update reference count of index
	if b0 and not b1:
		# Left hand side
		# e0 will no longer point to the configuration.
		Si = i.decrementRef(sys, slot)
	elif not b0 and b1:
		# Right hand side
		# e0 will now point to the configuration.
		Si = i.incrementRef(sys, slot)
	else:
		Si = (i,)

	return Si
	

def updateHitMiss(sys, e0, e1, b0, b1, slot, hits, misses):
	assert slot.isSlot(), slot

	#assert isinstance(hits, frozenset), hits
	#assert isinstance(misses, frozenset), misses


	
 	# Only retain valid expressions
	# 	The value of the expression does not change
	# 	or the location is stable, and "the assigned value misses the tracked location"

	# Note: I think there is a typo in the paper, as the following functions use "b1" in the paper.

	# If the target aliases with the configuration (b0),
	# The value of the hits may change, whereas the value of the misses will not change.
	# This is because the misses cannotnot alias to the target, therefore their value will not change.	
	# The location may change for both.

	# The opisite argument applies if the target does not alias the configuration.

	# If the expression aliases the configuration (b1), this gives us no insight into what's changing.


	stableValues = misses if b0 else hits
	newHits   = filterUnstable(sys, hits, slot, stableValues)
	newMisses = filterUnstable(sys, misses, slot, stableValues)


	e0StableLocation = e0.stableLocation(sys, slot, stableValues)
	e1StableLocation = e1.stableLocation(sys, slot, stableValues)


	# For "store" like statements... 
	# These type of statements will create a new hit or miss if the LHS is stable
	# If the configuration aliases with the RHS, it's a hit.  Else, a miss.

	if not e0.isTrivial() and e0StableLocation:
		if b1:
			# Aliases with the RHS, now aliases with the LHS
			newHits.add(e0)
		else:
			# Does not alias with the RHS, now cannot alias with the LHS
			newMisses.add(e0)


	# Substitutes *e0 where *e1 occurs.
	# Should this occur before filtering?
	if e0StableLocation and e1StableLocation:		
		substituteUpdate(sys, newHits, e1, e0)
		substituteUpdate(sys, newMisses, e1, e0)

	return newHits, newMisses

def assign(sys, outpoint, context, e0, e1, b0, b1, i, hits, misses, external):
	# Must not modify hits and misses
	
	# b0 -> e0 aliases to i
	# b1 -> e1 aliases to i

	if b0 and b1:
		# e0 must alias i, and e1 must alias i, therefore e0 must alias e1
		# This assigment therefore does nothing.
		secondary = sys.canonical.secondary(hits, misses, external)
		gcMerge(sys, outpoint, context, i, secondary)

		# TODO can we infer new hits/misses?
		return

	# The region being updated
	slot = e0.slot
	# TODO use the hits and misses for e0 to make stableLocation and stableValue more precise?
	# This, of course, requires figuring out what an expression can miss.

	# Map the original configuration onto the new configuration(s)
	Si = mapConfiguration(sys, i, slot, b0, b1)

	if Si:
		# TODO optimization: use secondary information from destination store to bound
		# possible hits and misses?
		
		# Aliasing issues can modify the hits and misses
		newHits, newMisses = updateHitMiss(sys, e0, e1, b0, b1, slot, hits, misses)

		# Discard "obvious" miss sets
		# All elements of Si will have the same references (but possibally different counts), so just check one.
		newMisses = filterTrivialMisses(sys, Si[0], newMisses)

		# Merge in the new info
		secondary = sys.canonical.secondary(newHits, newMisses, external)
		for newConf in Si:
			gcMerge(sys, outpoint, context, newConf, secondary)

def assignmentConstraint(sys, outpoint, context, e1, e0, index, hits, misses, external):
	assert e1.isExpression(), e1
	assert e0.isExpression(), e0


	if hits is not None:
		assert isinstance(hits, (set, frozenset, type(None))), hits
		for hit in hits:
			assert hit.isExpression(), hit

	if misses is not None:
		assert isinstance(misses, (set, frozenset, type(None))), misses
		for miss in misses:
			assert miss.isExpression(), miss


	# Must not modify hits and misses

	if hits is None: hits = set()
	if misses is None: misses = set()
	
	#assert isinstance(hits, frozenset)
	#assert isinstance(misses, frozenset)

	# Note: local expressions will never by uncertain.
	
	v0 = e0.refersTo(sys, index, hits, misses)
	e0Uncertain = v0 is expressions.MayAlias
	e0Must      = v0 is expressions.MustAlias

	v1 = e1.refersTo(sys, index, hits, misses)
	e1Uncertain = v1 is expressions.MayAlias
	e1Must      = v1 is expressions.MustAlias


	if not e0Uncertain:
		if not e1Uncertain:
			assign(sys, outpoint, context, e0, e1, e0Must, e1Must, index, hits, misses, external)
		else:
			assign(sys, outpoint, context, e0, e1, e0Must, True, index, hits.union((e1,)), misses, external)
			assign(sys, outpoint, context, e0, e1, e0Must, False, index, hits, misses.union((e1,)), external)

	else:
		if not e1Uncertain:
			assign(sys, outpoint, context, e0, e1, True, e1Must, index, hits.union((e0,)), misses, external)
			assign(sys, outpoint, context, e0, e1, False, e1Must, index, hits, misses.union((e0,)), external)

		else:
			assert False, "This case requires heap-to-heap data transfer, which is not allowed by the IR."
			
			assign(sys, outpoint, context, e0, e1, index, True, True, hits.union((e0, e1)), misses, external)
			assign(sys, outpoint, context, e0, e1, index, True, False, hits.union((e0,)), misses.union((e1,)), external)
			assign(sys, outpoint, context, e0, e1, index, False, True, hits.union((e1,)), misses.union((e0,)), external)
			assign(sys, outpoint, context, e0, e1, index, False, False, hits, misses.union((e0, e1)), external)
